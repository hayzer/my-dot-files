# Environment functions 
#

# Load the local environment
if [ -e ~/.local_functions ]; then
  source ~/.local_functions
fi


# Search the pstree
function pt () {
	declare search="${*}"
	pstree -paGh | ack ${search}
}

# Search the history
function ghistory () {
    var=$(history | ack $1 | wc -l)
	if (( $var > 22 )); then
		history | ack $1 | less
	else
		history | ack $1
	fi
}

# Save file deletion. 
function del () {
	declare target="${1}"
	
	/bin/cp -R ${target} ~/.Trash/ && /bin/rm -f ${target} 
}

# Improved grep. Short version.
function lookfor () {
	declare regexp="${1}"
	declare   path="${2}"

	/bin/grep --recursive                  \
              --line-number                \
		      --color=always               \
              --binary-files=without-match \
              --perl-regexp "${regexp}"    \
              ${path:=.} | grep -v '.svn'
}	

# Convert ascii string to SNMP OID address
function ascii2oid () {
	declare string=${1}
	declare length=${#string}
	declare newstring

	declare -a ascii2dec=( $(echo ${string}|sed -n 's/\(.\)/ \1/gp') )

	for elem in ${ascii2dec[@]}; do
		newstring="${newstring}$(printf ".%d" \"${elem}\")"
	done
	echo "${length}${newstring}"
}

function oid2ascii () {
	declare oid=${1}
	declare -a string=( $(echo ${oid//./ }) )
	declare ascii

	for i in ${string[@]}; do
		declare temp=$( perl -e 'print pack("C*",'${i}')' )
		ascii="${ascii}${temp}"
	done

	echo ${ascii}
}

function swalk () {
	declare  tag="${1}"
	declare   ip="${2}"
	declare prog="${3}"

	if [ -z "${tag}" ]; then
		echo "USAGE: swalk <tag> <ip|1> [<prog>]"
		return
	fi

	if [[ "X${ip}" = "X1" ]]; then
		ip=172.20.12.114
	fi

	if [ -n "${prog}" ]; then
		prog=".$( ascii2oid ${prog} )"
	else
		prog=''
	fi

	snmpwalk -v 2c -OQ -c public ${ip} ${tag}${prog} 2>/dev/null
	return $?
}

function autossh () {
	declare ip="${1}"

	if [ -z "${ip}" ]; then
		echo "Missing IP address"
		return
	fi

	if [ ! -e ~/.ssh/id_rsa.pub ]; then
		ssh-keygen -t rsa
	fi

	echo "No copy your key to the end of ~/.ssh/authorized_keys on ${ip}"
	cat ~/.ssh/id_rsa.pub
	ssh -l bbndserviceaccount ${ip}
}

# Locate dependency of Perl modules
function find-perl-module-use () {
	declare dir=${1:-lib}

	ack '^\s*use\s+.*;\s*$' ${dir} | \
	awk '{ print $2 }'             | \
	sed 's/();\?$\|;$//'           | \
	sort                           | \
	uniq

	ack '^\s*use\s+base\s+.*;\s*$' ${dir} | \
	awk '{ print $3 }'                    | \
	sed 's/();\?$\|;$//'                  | \
	sort                                  | \
	uniq
}

function wcopy () {
	declare path=${1}
	declare file=$( basename ${path} )

	echo "scp ${path} wis@www.quttera.com:~/wis/${path}"
	scp ${path} wis@www.quttera.com:~/wis/${path}
}

function cget () {
	declare path=${1}
	declare view=${2}
	declare header="Content-type: application/json"
	declare address="http://localhost:17670"

	if [[ 'x${view}' != "x" ]]; then
		path="${path}/_design/couchapp/_view/${view}"
	fi
	curl -s ${header} ${address}${path}
}

function google () {
	u=`perl -MURI::Escape -wle 'print "http://google.com/search?q=".
	uri_escape(join " ", @ARGV)' $@`
	w3m -no-mouse -F $u
}

function gilo () {
	git log -n30 --pretty=tformat:"^%h^%aN^%ai^|^%d^%s" $@ |
		TERM_COLUMNS=$COLUMNS perl -F'\^' -lane '
			my $WIDTH = $ENV{TERM_COLUMNS} - 49 - length($F[0]) - length($F[5]);
			if (scalar @F == 1)
			{
				printf("                                               %.${WIDTH}s\n", $F[0])
			}
			else
			{
				printf("\033[32m$F[1] \033[33m%-19s \033[0m%.16s \033[31m%s\033[0m%s\033[0;31m%s\033[0m%-.${WIDTH}s\n",
					$F[2], $F[3], $F[4], length($F[0]) ? " $F[0]" : " ", length($F[5]) ? "$F[5] " : "", @F[6..10]);
			}
		'
}

# Open any archive
function ex () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjvf $1        ;;
      *.tar.gz)    tar xzvf $1     ;;
      *.bz2)       bunzip2 $1       ;;
      *.rar)       rar x $1     ;;
      *.gz)        gunzip $1     ;;
      *.tar)       tar xf $1        ;;
      *.tbz2)      tar xjf $1      ;;
      *.tgz)       tar xzf $1       ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1    ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# vim ts=4 sw=4 syn=sh :
