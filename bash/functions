# Environment functions 
#

# Load the local environment
if [ -e ~/.local_functions ]; then
  source ~/.local_functions
fi


# Search the pstree
function pt () {
	declare search="${*}"
	pstree -paGh | ack ${search}
}

# Search the history
function ghistory () {
    var=$(history | ack $1 | wc -l)
	if (( $var > 22 )); then
		history | ack $1 | less
	else
		history | ack $1
	fi
}

# Save file deletion. 
function del () {
	declare target="${1}"
	
	/bin/cp -R ${target} ~/.Trash/ && /bin/rm -f ${target} 
}

# Improved grep. Short version.
function lookfor () {
	declare regexp="${1}"
	declare   path="${2}"

	/bin/grep --recursive                  \
              --line-number                \
		      --color=always               \
              --binary-files=without-match \
              --perl-regexp "${regexp}"    \
              ${path:=.} | grep -v '.svn'
}	

# Convert ascii string to SNMP OID address
function ascii2oid () {
	declare string=${1}
	declare length=${#string}
	declare newstring

	declare -a ascii2dec=( $(echo ${string}|sed -n 's/\(.\)/ \1/gp') )

	for elem in ${ascii2dec[@]}; do
		newstring="${newstring}$(printf ".%d" \"${elem}\")"
	done
	echo "${length}${newstring}"
}

function oid2ascii () {
	declare oid=${1}
	declare -a string=( $(echo ${oid//./ }) )
	declare ascii

	for i in ${string[@]}; do
		declare temp=$( perl -e 'print pack("C*",'${i}')' )
		ascii="${ascii}${temp}"
	done

	echo ${ascii}
}

function swalk () {
	declare  tag="${1}"
	declare   ip="${2}"
	declare prog="${3}"

	if [ -z "${tag}" ]; then
		echo "USAGE: swalk <tag> <ip|1> [<prog>]"
		return
	fi

	if [[ "X${ip}" = "X1" ]]; then
		ip=172.20.12.114
	fi

	if [ -n "${prog}" ]; then
		prog=".$( ascii2oid ${prog} )"
	else
		prog=''
	fi

	snmpwalk -v 2c -OQ -c public ${ip} ${tag}${prog} 2>/dev/null
	return $?
}

function autossh () {
	declare ip="${1}"

	if [ -z "${ip}" ]; then
		echo "Missing IP address"
		return
	fi

	if [ ! -e ~/.ssh/id_rsa.pub ]; then
		ssh-keygen -t rsa
	fi

	echo "No copy your key to the end of ~/.ssh/authorized_keys on ${ip}"
	cat ~/.ssh/id_rsa.pub
	ssh -l bbndserviceaccount ${ip}
}

# Locate dependency of Perl modules
function find-perl-module-use () {
	declare dir=${1:-lib}

	ack '^\s*use\s+.*;\s*$' ${dir} | \
	awk '{ print $2 }'             | \
	sed 's/();\?$\|;$//'           | \
	sort                           | \
	uniq

	ack '^\s*use\s+base\s+.*;\s*$' ${dir} | \
	awk '{ print $3 }'                    | \
	sed 's/();\?$\|;$//'                  | \
	sort                                  | \
	uniq
}

function wcopy () {
	declare path=${1}
	declare file=$( basename ${path} )

	echo "scp ${path} wis@www.quttera.com:~/wis/${path}"
	scp ${path} wis@www.quttera.com:~/wis/${path}
}

function cget () {
	declare path=${1}
	declare view=${2}
	declare header="Content-type: application/json"
	declare address="http://localhost:17670"

	if [[ 'x${view}' != "x" ]]; then
		path="${path}/_design/couchapp/_view/${view}"
	fi
	curl -s ${header} ${address}${path}
}

function google () {
	u=`perl -MURI::Escape -wle 'print "http://google.com/search?q=".
	uri_escape(join " ", @ARGV)' $@`
	w3m -no-mouse -F $u
}

function gilo () {
	git log -n30 --pretty=tformat:"^%h^%aN^%ai^|^%d^%s" $@ |
		TERM_COLUMNS=$COLUMNS perl -F'\^' -lane '
			my $WIDTH = $ENV{TERM_COLUMNS} - 49 - length($F[0]) - length($F[5]);
			if (scalar @F == 1)
			{
				printf("                                               %.${WIDTH}s\n", $F[0])
			}
			else
			{
				printf("\033[32m$F[1] \033[33m%-19s \033[0m%.16s \033[31m%s\033[0m%s\033[0;31m%s\033[0m%-.${WIDTH}s\n",
					$F[2], $F[3], $F[4], length($F[0]) ? " $F[0]" : " ", length($F[5]) ? "$F[5] " : "", @F[6..10]);
			}
		'
}

# git prompt
function __git_ps1 () { 
    local g="$(__gitdir)";
    if [ -n "$g" ]; then
        local r="";
        local b="";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
            b="$(cat "$g/rebase-merge/head-name")";
        else
            if [ -d "$g/rebase-merge" ]; then
                r="|REBASE-m";
                b="$(cat "$g/rebase-merge/head-name")";
            else
                if [ -d "$g/rebase-apply" ]; then
                    if [ -f "$g/rebase-apply/rebasing" ]; then
                        r="|REBASE";
                    else
                        if [ -f "$g/rebase-apply/applying" ]; then
                            r="|AM";
                        else
                            r="|AM/REBASE";
                        fi;
                    fi;
                else
                    if [ -f "$g/MERGE_HEAD" ]; then
                        r="|MERGING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
                b="$(git symbolic-ref HEAD 2>/dev/null)" || { 
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." || b="unknown";
                    b="($b)"
                };
            fi;
        fi;
        local w="";
        local i="";
        local s="";
        local u="";
        local c="";
        local p="";
        if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
            if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                c="BARE:";
            else
                b="GIT_DIR!";
            fi;
        else
            if [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
                if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
                    if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                        git diff --no-ext-diff --quiet --exit-code || w="*";
                        if git rev-parse --quiet --verify HEAD > /dev/null; then
                            git diff-index --cached --quiet HEAD -- || i="+";
                        else
                            i="#";
                        fi;
                    fi;
                fi;
                if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
                    git rev-parse --verify refs/stash > /dev/null 2>&1 && s="$";
                fi;
                if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
                    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                        u="%";
                    fi;
                fi;
                if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                    __git_ps1_show_upstream;
                fi;
            fi;
        fi;
        local f="$w$i$s$u";
        printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p";
    fi
}

# Open any archive
function ex () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xjf $1        ;;
      *.tar.gz)    tar xzf $1     ;;
      *.bz2)       bunzip2 $1       ;;
      *.rar)       rar x $1     ;;
      *.gz)        gunzip $1     ;;
      *.tar)       tar xf $1        ;;
      *.tbz2)      tar xjf $1      ;;
      *.tgz)       tar xzf $1       ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1    ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# vim ts=4 sw=4 syn=sh :
